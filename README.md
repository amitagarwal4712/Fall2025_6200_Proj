# Project 1 Fall 2025 Cryptography- ITIS6200
## üõ†Ô∏è Requirements

- Python 3.x
## üß∞ Installation

Install dependencies:
```bash
pip install pycryptodome
```

## üöÄ Task # 1 - Digital Signature

### Function 1- Key Generation
```bash
python DigitalSign.py -g key
```
### Function 2- Hash message

```bash
python DigitalSign.py -m "This is message to Bob from Alice"
```
### Function 3- Sign a message

```bash
python DigitalSign.py -s sign -m "this is from alice to bob" -sk <"private key from Function 1 output">
```
### Function 4- Verify signtaure message

```bash
python DigitalSign.py -v verify -m "message used while signed in function 3" -pk "public key from function 1 output" -ss "signature from function 3 output"
```
Output: 1 if verified, 0 if verification failed

## üöÄ Task # 1 - Digital Signature - RSA style based on 2 prime factor p and q 
### Function 1- Key Generation
```bash
python RSADigitalSign.py -g key
```
### Function 2- Hash message

```bash
python RSADigitalSign.py -m "This is message to Bob from Alice"
```
### Function 3- Sign a message

```bash
python RSADigitalSign.py -s sign -m "this is the message from alice to Bob" -d "private key 'd' from Function 1" -N "public key 'N' from function 1"
```
### Function 4- Verify signtaure message

```bash
python RSADigitalSign.py -v verify -m "message used while signed in function 3" -e "public key exponent 'e' from function 1" -N "public key 'N' from function 1" -ss "signature genetaed in function 3"
```
Output: 1 if verified, 0 if verification failed

## üöÄ Task # 2 - Diffie-Hellmen Key exchange
 
### Step 1- Pick 2 public value, P (large prime number) and G (generator)
Those values are set into file, task2_Diffie_hellman_exchg_FUNC.py and will be used in step 2. 
Current value P=176478739768874059356517070832095509771, G=5119

### Step 2 - Alice and Bob can run this on their terminal

#### Step 2.1 - Alice/Bob generate a secret value, respectively. process will first generates secret <br>for Alice a and g<sup>a</sup>ModP <br> for Bob b and g<sup>b</sup>ModP.
```bash
python task2_Diffie_hellman_exchg.py -g key
```
<b>Output like:</b><br>
Large Prime Number P : 176478739768874059356517070832095509771 <br>
Generator G : 5119 <br>
Random secret number  for alice/bob [ab] is : 39794111844673341527981300271877057382 <br>
secret generated by Alice/Bob g[ab] mod P : 173545600121513571777169802376557686450  <br>

#### Step 2.2 - Alice/Bob generate a signature on with the help of their secret key generated in task#1 respectively. .
```bash
python DigitalSign.py -s sign -m <"Alice - g<sup>a</sup>ModP ,for Bob - g<sup>b</sup>ModP> -sk <secret ley of Alice/Bob>
```
output: Genmerate signature for Alice/Bob

### Step 3- Alice/Bob need to verify signature with message value g<sup>a</sup>ModP or g<sup>b</sup>ModP and signature they receive from others. <br>Alice and Bob can run this on their terminal by providing public  key of other's
```bash
python DigitalSign.py -v verify -m <message> -pk <public key> -ss <signature>
```
output: Returns 1 if verification is successfull else returns 0

### Step 4- Compute the shared secret g<sup>ab</sup>ModP<br>Alice and Bob can run this on their terminal
```bash
python task2_Diffie_hellman_exchg.py -c calculate -p <a or b  value> -s <g<sup>a</sup>modp or g<sup>b</sup>mod p>
```
output: Computed secret value g<sup>ab</sup>ModP

## üöÄ Task # 3 - Encryption Key Derivation
### Function - Key Derivation
#### Get the shared secret for value of 'k' from Task #2. n is the number, how many time want to hashed
```bash
python task3_keyderivation.py -k <secretkey> -n <times to be hashed>
```
output: Hashed secret key in hex format

## üöÄ Task # 4 - Pseudo-Random Number Generation (PRNG)
### Step -1 - function screenshot, attached in document
### Step -2 - Randomness, sequence of output, -n means how many number need to generate
```bash
python task4_PRNG.py -n <count>
```
Output: returns sequence of random different n numbers with bydefault seed value 2692698

### Step -3 - Deterministic, 2 sequence of output with same seeded value, execute following command with same sees value , -n means how many number need to generate
```bash
python task4_PRNG.py -s <seed value>  -n <count>
```
Output: returns 2 identical sequence of n different random numbers with same seed value

### Step -4 - seeding(re-seeding) impact - put same seed value for both of following commands and reseed value in 2nd command, -n means how many number need to generate
```bash
python task4_PRNG.py -s <seed value>  -n <count>
```
Output: returns sequence of n different random numbers

```bash
python task4_PRNG.py -s <seed value>  -r <reseed value>  -n <count>
``` 
Output: returns different sequence from previous one of different n random numbers because of reseeded value for same seed value

## üöÄ Task # 5 - Secure Message Exchange
### Step -1 - Encrypt then HMAC function  <br>This first calls sym_enc function (AES-CBC encryption), which returns the IV+Cipher Text <br> then HMAC function is called which used this IV+CipherText as message and returns CipherText + HMAC TAG <br> Secret key from task #3 derivated function used <br> HMAC key , used same as secret key<br> IV from task #4
```bash
python task5_SecureMessageExchange.py -sk <secret key from task 3 derivated function> -hk <secret key from task 3 derivated function> -i <IV from task #4 PRNG> -m <message>
```
Input: -sk    secret key,  -hk    HMAC prime key,  -i    IV,  -m  message
Output: Ciphertext + HMAC tag

### Step -2 -HMAC verification then decrypt function  <br>This first calls HMAC verification if successful then calls sym_dec function to return plain text <br> Secret key from task #3 derivated function used <br> HMAC key , used same as secret key
```bash
python task5_SecureMessageExchange.py -sk <secret key from task 3 derivated function> -hk <secret key from task 3 derivated function>  -c <output of Step 1 >
```
Output: If HMAC tag is verified successfully, returns the plain text else returns the tag tempered message 
